# 다형성`(polymorphism)`2

### 다형성의 활용 1
 
 * 다형성을 왜 사용하는지 그 장점을 알아보기 위해 단순하고 전통적인 동물소리 문제로 접근해 본다
   * `Dog`의 `sound()` 
   * `Cat`의 `sound()` 
   * `Cow`의 `sound()` 
 * 를 이용해 다형성을 사용하지 않고 코드를 만들어 보았다
    * `main`
```java
    System.out.println("동물 소리 테스트 시작");
    동물(개, 고양이, 소 등).sound();
    System.out.println("동물 소리 테스트 종료");
```

 * 단순히, 개 , 고양이, 소 동물의 울음 소리를 출력하는 프로그램인데
 * 새로운 동물이 추가 된다면 어떨까?
 * 여기에 오리(Duck)가 추가 된다면?
 * `Duck duck = new Duck();`을 생성하는 부분은 당여히 필요하니 크게 상관 없지만
 * 출력하는 부분은 계속 중복이 된다.
 * 이 중복을 제거하기 위해 메서드나 배열과 `for`문을 사용해 볼 수있다
 * 하지만, 개, 소, 고양이, 오리는 서로 완전히 다른 클래스이기 때문에
 * 쉽지 않다
 * 배열에 담아 처리 하려고 해도 배열의 타임을 지정헤야 하는데 서로 다른 타입들을 하나의 배열에 담는 것은 불가는하다
 * 여기서 문제의 핵심은 타입이 다르다는 것
 * 개, 고양이, 소, 오리가 모두 같은 타입을 사용할 수 방법이 있다면 중복을 제거할 수 있을 것이다.(다형성을 활용해보자)

### 다형성의 활용 2

 * 앞서 살펴본 예제를 다형성을 활용해 변경해본다
 * 상속 관계를 사용하기 위해 `Animal` 이라는 부모클래스를 만들고 `sound()`메서드를 정의한다.
  ```java
  System.out.println("동물 울음 소리");
  ```
 * 이 메서드는 자식클래스에서 오버라이딩 할 목적으로 사용
 * 개, 고양이, 소 클래스는 `Animal`클래스를 상속 받고 각각 `sound()`메서드를 오버라이딩 한다(인텔리제이에서 `control` + `o` 를 사용하면 오버라이딩할 메서드를 만들어 준다)
  ```java
  System.out.println("멍멍"); //이런식으로 오버라이딩
  ```
 * `main` 에서 `soundAnimal`을 정의 해주고 사용
```java
{
Dog dog = new Dog();
.
.
.
soundAnimal(dog);
}
soundAnimal(Animal animal){}
``` 

    ** 실행 결과 **
                
        동물 소리 테스트 시작
        멍멍
        동물 소리 테스트 종료

 * `soundAnimal(dog)`를 호출하면
 * `soundAnimal(Animal animal)`에 `Dog`인스턴스가 전달된다
   * `Animal animal = dog` 로 이해, **부모는 자식을 담을 수있다**
 * `animal`변수의 타입은 `Animal`이므로 `Dog`인스턴스에 있는 `Animal`클래스 부분을 찾아 
 * `sound()`메서드를 실행한다. 그런데 하위 클래스인 `Dog`에서 `sound()`메서드를 오버라이딩 했기 때문에 오버라이딩한 메서드가 우선권을 가져
 * `Dog`에 있는 `sound()`메서드가 호출이 된다.

### 추상 클래스 1
 * 이제 여기서 남은 문제는 
   * `Animal`클래스를 생성할 수 있는 문제
     
     * `Animal`은 동물이라는 클래스이다. 이 클래스는 직접 생성하여 사용할 일이 없다
     * 다형성을 위해 필요하지 직접 인스턴스를 생성할 필요가 없다
     * 하지만 `Animal`도 클래스 이기 때문에 인스턴스를 사용하는데 
     * 아무런 제약이 없다
   
   * `Animal`클래스를 상속 받는 곳에서 메서드를 오버라이딩 하지 않을 가능성
     
     * 예를 들자면 `오리`라는 새로운 클래스를 만들 때 우리가 기대하는 것은 
     * 오리가 "꽉꽉" 소리가 나도록 오버라이딩 하는 것이다.
     * 개발자가 실수로 어버라이딩하는 것을 빠트릴 수 있다. 이렇게 되면 부모의 기능을 상속받아 부모의 메서드가 호출이 된다. 
 * 추상클래스와 추상 메서드를 사용하면 이런 문제를 해결할 수있다.

#### **김영한 강사님께서 항상 하시는 말씀**
> ##### "좋은 프로그램은 적절한 제약이 있는 프로그램이다"
 
 #### 추상 클래스
 * 동물과 같이 부모클래스는 제공하지만, 실제 생성되면 안되는 클래스를 추상 클래스 라고 한다
 * 추상클래스는 이름 그대로 추상적인 개념을 제공하는 클래스다
 * 상속목적으로 사용되고, 부모클래스의 역할을 담당한다
  
 * 추상 클래스를 선언할 때는 `abstaract`라는 키워드를 붙여 주면된다.
```java
abstract class Animal{}
```
 * 추상 클래스는 기존클래스와 같지만, 직접인스터스를 생성하지 못한다

#### 추상 메서드
 * 부모클래스를 상속받는 자식 클래스가 반드시 오버라이딩을 해야 메서드를 정의 할 수있다.
 * 추상적인 개념을 제공하는 메서드
 * 실체가 존재하지 않고, 메서드 바디가 없다
```java
public abstract void sound();
``` 
 * 메서드 앞에 `abstract`란 키워드를 붙여 주면 되고,
 * 추상 메서드가 하나라도 있는 클래슨 추상 클래스로 선언하여야 한다.
 * 추상 메서드를 상속받는 자식 클래스는 **반드시 오버라이딩 해서 사용해야 한다**
 
   * 그렇지 않으면 컴파일 오류 발생
 
 * 추상 메서드는 기존 메서드와 완전히 같다.
 * 메서드 바디가 없고, 자식 클래스가 해당 메서드를 반드시 오버라이딩 해야 한다는 제약이 있다는 것이 차이점이다. 

 * 추상 클래스 덕분에 실수로 `Animal`인스턴스를 생성할 문제를 근본적으로 방지
 * 실수로 오버라이딩 하지 않을 문제를 근본적으로 방지

### 추상 클래스2
   **순수 추상클래스**
   ```java
    public abstract class AbstractAnimal {
    public abstract void sound();
    public abstract void move();
    }
   ```
 * 모든 메서드가 추상 메서드인 클래스를 순수 추상 클래스라한다
 * 추상 클래스는 실행 로직을 전혀 가지고 있지 않다. 
 * 다형성을 위한 부모 타입으로써의 껍데기 역할만 할 뿐
 * 순수 추상 클래스 특징
   * 인스턴스 생성 X
   * 상속시 자식은 모든 메서드를 오버라이딩 해야한다
   * 주로 다형성을 위해 사용
 * "상속시 자식은 모든 메서드를 오버라이딩 해야 한다." 라는 말은 상속 받는 클래스 입장에서 보면 부모의 모든 메서드를 구현해야 한다는 것
 * 이런 특징은 순수 추상 클래스는 마치 규격을 규정하는 것 처럼 보인다
 * 순수 추상프로그램의 개념은 프로그래밍에서 매우 자주 사용되는데
 * 자바는 순수 추상 클래스를 더 편하게 사용할 수 있도록 인터페이스라는 개념을 제공한다.
  (2024.10.25)
### 인터페이스
