# 다형성`(polymorphism)`2

### 다형성의 활용 1
 
 * 다형성을 왜 사용하는지 그 장점을 알아보기 위해 단순하고 전통적인 동물소리 문제로 접근해 본다
   * `Dog`의 `sound()` 
   * `Cat`의 `sound()` 
   * `Cow`의 `sound()` 
 * 를 이용해 다형성을 사용하지 않고 코드를 만들어 보았다
    * `main`
```java
    System.out.println("동물 소리 테스트 시작");
    동물(개, 고양이, 소 등).sound();
    System.out.println("동물 소리 테스트 종료");
```

 * 단순히, 개 , 고양이, 소 동물의 울음 소리를 출력하는 프로그램인데
 * 새로운 동물이 추가 된다면 어떨까?
 * 여기에 오리(Duck)가 추가 된다면?
 * `Duck duck = new Duck();`을 생성하는 부분은 당여히 필요하니 크게 상관 없지만
 * 출력하는 부분은 계속 중복이 된다.
 * 이 중복을 제거하기 위해 메서드나 배열과 `for`문을 사용해 볼 수있다
 * 하지만, 개, 소, 고양이, 오리는 서로 완전히 다른 클래스이기 때문에
 * 쉽지 않다
 * 배열에 담아 처리 하려고 해도 배열의 타임을 지정헤야 하는데 서로 다른 타입들을 하나의 배열에 담는 것은 불가는하다
 * 여기서 문제의 핵심은 타입이 다르다는 것
 * 개, 고양이, 소, 오리가 모두 같은 타입을 사용할 수 방법이 있다면 중복을 제거할 수 있을 것이다.(다형성을 활용해보자)

### 다형성의 활용 2

 * 앞서 살펴본 예제를 다형성을 활용해 변경해본다
 * 상속 관계를 사용하기 위해 `Animal` 이라는 부모클래스를 만들고 `sound()`메서드를 정의한다.
  ```java
  System.out.println("동물 울음 소리");
  ```
 * 이 메서드는 자식클래스에서 오버라이딩 할 목적으로 사용
 * 개, 고양이, 소 클래스는 `Animal`클래스를 상속 받고 각각 `sound()`메서드를 오버라이딩 한다(인텔리제이에서 `control` + `o` 를 사용하면 오버라이딩할 메서드를 만들어 준다)
  ```java
  System.out.println("멍멍"); //이런식으로 오버라이딩
  ```
 * `main` 에서 `soundAnimal`을 정의 해주고 사용
```java
{
Dog dog = new Dog();
.
.
.
soundAnimal(dog);
}
soundAnimal(Animal animal){}
``` 

    ** 실행 결과 **
                
        동물 소리 테스트 시작
        멍멍
        동물 소리 테스트 종료

 * `soundAnimal(dog)`를 호출하면
 * `soundAnimal(Animal animal)`에 `Dog`인스턴스가 전달된다
   * `Animal animal = dog` 로 이해, **부모는 자식을 담을 수있다**
 * `animal`변수의 타입은 `Animal`이므로 `Dog`인스턴스에 있는 `Animal`클래스 부분을 찾아 
 * `sound()`메서드를 실행한다. 그런데 하위 클래스인 `Dog`에서 `sound()`메서드를 오버라이딩 했기 때문에 오버라이딩한 메서드가 우선권을 가져
 * `Dog`에 있는 `sound()`메서드가 호출이 된다.

### 추상 클래스 1
 * 이제 여기서 남은 문제는 
   * `Animal`클래스를 생성할 수 있는 문제
     
     * `Animal`은 동물이라는 클래스이다. 이 클래스는 직접 생성하여 사용할 일이 없다
     * 다형성을 위해 필요하지 직접 인스턴스를 생성할 필요가 없다
     * 하지만 `Animal`도 클래스 이기 때문에 인스턴스를 사용하는데 
     * 아무런 제약이 없다
   
   * `Animal`클래스를 상속 받는 곳에서 메서드를 오버라이딩 하지 않을 가능성
     
     * 예를 들자면 `오리`라는 새로운 클래스를 만들 때 우리가 기대하는 것은 
     * 오리가 "꽉꽉" 소리가 나도록 오버라이딩 하는 것이다.
     * 개발자가 실수로 어버라이딩하는 것을 빠트릴 수 있다. 이렇게 되면 부모의 기능을 상속받아 부모의 메서드가 호출이 된다. 
 * 추상클래스와 추상 메서드를 사용하면 이런 문제를 해결할 수있다.

#### **김영한 강사님께서 항상 하시는 말씀**
> ##### "좋은 프로그램은 적절한 제약이 있는 프로그램이다"
 
 #### 추상 클래스
 * 동물과 같이 부모클래스는 제공하지만, 실제 생성되면 안되는 클래스를 추상 클래스 라고 한다
 * 추상클래스는 이름 그대로 추상적인 개념을 제공하는 클래스다
 * 상속목적으로 사용되고, 부모클래스의 역할을 담당한다
  
 * 추상 클래스를 선언할 때는 `abstaract`라는 키워드를 붙여 주면된다.
```java
abstract class Animal{}
```
 * 추상 클래스는 기존클래스와 같지만, 직접인스터스를 생성하지 못한다

#### 추상 메서드
 * 부모클래스를 상속받는 자식 클래스가 반드시 오버라이딩을 해야 메서드를 정의 할 수있다.
 * 추상적인 개념을 제공하는 메서드
 * 실체가 존재하지 않고, 메서드 바디가 없다
```java
public abstract void sound();
``` 
 * 메서드 앞에 `abstract`란 키워드를 붙여 주면 되고,
 * 추상 메서드가 하나라도 있는 클래슨 추상 클래스로 선언하여야 한다.
 * 추상 메서드를 상속받는 자식 클래스는 **반드시 오버라이딩 해서 사용해야 한다**
 
   * 그렇지 않으면 컴파일 오류 발생
 
 * 추상 메서드는 기존 메서드와 완전히 같다.
 * 메서드 바디가 없고, 자식 클래스가 해당 메서드를 반드시 오버라이딩 해야 한다는 제약이 있다는 것이 차이점이다. 

 * 추상 클래스 덕분에 실수로 `Animal`인스턴스를 생성할 문제를 근본적으로 방지
 * 실수로 오버라이딩 하지 않을 문제를 근본적으로 방지

### 추상 클래스2
   **순수 추상클래스**
   ```java
    public abstract class AbstractAnimal {
    public abstract void sound();
    public abstract void move();
    }
   ```
 * 모든 메서드가 추상 메서드인 클래스를 순수 추상 클래스라한다
 * 추상 클래스는 실행 로직을 전혀 가지고 있지 않다. 
 * 다형성을 위한 부모 타입으로써의 껍데기 역할만 할 뿐
 * 순수 추상 클래스 특징
   * 인스턴스 생성 X
   * 상속시 자식은 모든 메서드를 오버라이딩 해야한다
   * 주로 다형성을 위해 사용
 * "상속시 자식은 모든 메서드를 오버라이딩 해야 한다." 라는 말은 상속 받는 클래스 입장에서 보면 부모의 모든 메서드를 구현해야 한다는 것
 * 이런 특징은 순수 추상 클래스는 마치 규격을 규정하는 것 처럼 보인다
 * 순수 추상프로그램의 개념은 프로그래밍에서 매우 자주 사용되는데
 * 자바는 순수 추상 클래스를 더 편하게 사용할 수 있도록 인터페이스라는 개념을 제공한다.
  (2024.10.25)
### 인터페이스
 * 자바는 순수 추상 클래스를 더 편하게 사용할 수 있는 인터페이스라는 기능을 제공한다
 * 인터페이스는 `class` 가 아니라 `insterface` 키워드 사용
 * 인터페이스의 메서드는 모두 `public` `abstract`이다
 * 그래서 인터페이스에서 메서드 생성시 `public` `abstract` 생략가능하다. 참고로 생략이 권장됨
 * 인터페이스는 다중 구현(다중 상속)을 지원한다
    
    * 순수 추상 클래스의 특징
      
      * 인스턴스를 생성할 수 없다
      * 상속시 모든 메서드를 오버라이딩 해야함
      * 주로 다형성을 위해 사용
 * 인터페이스에서 멤버 변수는 `public` `static` `final` 이 모두 포함되어 있다고 간주된다 
 * `final` 은 변수의 값을 한번 결정하면 수정할 수 없다는 뜻
 * 자바에서 `static final`을 사용해 정적이면서 고칠 수 없는 변수를 상수라 하고, 관례상 상수는 대문자에 언더스코어로 구분
 * 인터페이스를 상속받을 때는 `extends` 대신 `implements`라는 구현이라는 키워드를 사용해야 한다.
 * 그래서 인터페이스를 상속한다 하지 않고, 구현한다 라고 표현한다.
#### 클래스, 추상클래스, 인터페이스는 모두 똑같다
 * 클래스, 추상 클래스, 인터페이는 프로그램 코드, 메모리 구조상 모두 똑같다. 모두 자바에서는 `.class`로 다루어진다

#### 인터페이스를 사용해야 하는 이유
 * `제약` : 인터페이스를 만드는 이유는 인터페이스를 구현하는 곳에서 인터페이스를 반드시 구현해라는 제약을 주는 것이다. 그런데 순수 추상 클래스의 경우 미래에 누군가 그곳에 실행 가는한 메서드를 끼워 넣을 수 있다. 이렇게 되면 추가되 기능을 자식 클래스에서 구현하지 않을 수도 있고, 또 더는 순수 추상 클래스가 아니게 된다. 인터페이스는 모든 메서드가 추상메서드이다. 위에 언급된 문제들을 원천에 차단할 수 있다.
 * `다중구현` : 자바에서 클래스 상속은 부모를 하나만 지정할 수 있지만, 인터페이스는 다중구현(다중 상속)이 가능하다.
### 인터페이스 다중 구현
 * 클래스 다중 상속이 허용이 된다면 `다이아몬드 문제`가 발생하며 상속받은 같은이름의 메서드들 중에 어떤 메서드를 사용할지 클래스 계층구조가 복잡해 지는 문제가 생긴다.
 * 하지만, 인터페이스를 사용한 다중구현(다중상속)에서는 인터페이스의 메서드는 모두 추상 메서드로 이루어지기 때문에 다중 구현이 가능하게 된다.
 * `InterfaceA`, `InterfaceB`가 있고 두 인터페이스 모두  `methodCommon()` 이라는 메서드를 가지고 있다고 가정해 보자
 * `Child`에서 `methodCommon()` 를 구현 한다고 했을때 `InterfaceA`, `InterfaceB` 에서 같은 이름에 메서드를 제공하지만 이것으 기능은 `Child`가 구현한다 그리고 오버라이딩에 의해 `Child`에 있는 `methodCommon()`가 호출이 된다. 결과 적으로 두 부모중에 어떤 한 부모의 메서드를 선택하는 것이 아닌 그냥 인터페이스들을 구현한 `Child`의 메서드가 사용이 되는것이다.
 * 이런 이유로 인터페이스의 다이아몬드 문제는 발생하지 않고, 다중 구현을 허용한다

## 좋은 프로그램은 제약이 있는 프로그램이다.
  
  