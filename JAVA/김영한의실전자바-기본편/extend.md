# Extends

## 상속관계

* 상속을 객체 지향 프로그램의 핵심 요소이다.
* 기존 클래스의 필드와 메서드를 새로운 클래스에서 재사용이 가능하게 해준다
* 기존 클래스의 속성과 기능을 그대로 물려 받는것
* `extends`  키워드를 사용한다. 대상은 하나만 선택할 수 있다
* 부모 클래스(슈퍼 클래스) : 상속을 통해 자신의 필드와 메서드를다른 클래스에 제공하는 클래스
* 자식 클래스(서브 클래스) : 부모클래스로 부터 필드와 메서드를 상속받는 클래스
* 상속은 부모기능을 자식이 물려 받는 것
* 따라서, 자식이 부모의 기능을 물려받아 사용할 수 있다.
* 하지만, 그 반대는 아니다. 부모코드를 보면 자식의 대한 정보가 없다 

### 단일 상속
--------------------------------------------
* 자바는 다중상속을 지원하지 않는다.
* `extends` 의 대상은 하나만 선택할 수 있다. 
* 부모를 하나만 선택할 수 있다는 뜻이다
* 부모가 또 다른 부모를 가지는 것은 가능하다.

### 다중상속 문제점
* 다중상속을 사용하면 자식 클래스가 부모의 어떤 기능(메서드)를 사용해야 할지 모호한 문제가 발생
* 이것을 다이아몬드 문제라고 한다
* 다중상속을 이용하면 클래스 계층구조가 매우 복잡해질 수 있다.
* 대신 인터페이스의 다중 구현을 통해 이러한 문제를 해결한다.

## 중요!!!
* 상속관계의 객체를 생성하면 그 내부에는 부모와 자식이 모두 생성된다
* 상속 관계의 객체를  호출할 때, 대상 타입을 정해야 한다. 이때 호출자의 타입을 통해 대상 타입을 찾는다.,
* 현재 타입에서 기능을 찾지 못하면 상위 부모 타입으로 기능을 찾아서 실행한다. 기능을 찾지 못하면 컴파일 오류가 발생한다.

### 상속의 기능 추가
* 상속관계 덕분에 중복은 줄어들고 편리하게 확장이 가능하다.
* 새로운 자식클래스 추가시 공통적인 메서드를 부모 클래스에 추가하면 쉽게 그 기능을 가져다 사용할 수 있다. 

### 상속과 메서드 오버라이딩
* 부모 타입의 기능을 자식에서 다르게 재정의 하는것을 오버라이딩이라고 한다 (오버로딩과 헷갈리지 말자)
* 메서등의 이름은 같지만 새로운 기능을 사용하고 싶을 때 사용한다.
* `@Override`   (`@`  이가 붙은 부분을 애노테이션이라고 한다. 애노테이션은 주석과 비슷한데, 프로그램이 읽을 수 있는 특별한 주석)
* 이 애노테이션은 상위 클래스의 메서드를 오버라이드 하는 것임을 나타낸다.
* 오버라이딩한 메서드 위에 애노테이션을 붙이면 컴팡일러는 메서드가 정확히 오버라이드 되었는지 확인한다.
* 오버라이딩 조건을 만족시키지 않은면 컴파일 에러를 발생시킨다.
* 필수 기능은 아니지만 코드의 명확성을 위해 붙여주는게 좋다.

#### 오버로딩(Overloading) 과 오버라이딩(Overriding) 

* 오버로딩 : 메서드 이름이 같고 매개변수(파라미터)가 다른 메서드를 여러개 정의하는 것을 말한다
* 오버라이딩 : 오버 라이딩은 하위 클래스에서 상위 클래스의 메서드를 재정의 하는 과정을 의미한다. 상속관계에서 사용!

### 메서드 오버라이딩의 까다로운 조건

* 메서드 이름이 같아야 한다
* 매개변수,타입,순서, 개수가 같아야 한다
* 반환 타입이 같아야 한다.
* 상위 클래스의 접근제어자 보다 제한적이어서는 안된다
* 상위 클래스의 메서드보다 더 많은 체크예외를 throws  로 선언할 수 없다.
* static , final , private  가 붙은 메서드는 오버라이딩 될 수 없다
* 생성자는 오버라이딩 할 수  없다.

### 상속과 접근 제어

* 접근 제어자의 종류
  * public : 모드 외부 호출을 허용
  * protected  :  같은 패키지안에서 호출은 허용한다 . 패키지가 달라도 상속관계의 호출은 허용한다.
  * default  : 같은 패키지안에서 호출은 허용한다
  * private  : 모든 외부 호출을 막는다.
* 본인 타입에 없으면 부모 타입에서 기능을 찾는데, 이때 접근 제어자가 영향을 준다. 
* 객체 내부에서는  자식과 부모가 구분되어 있기 때문이다.
* 자식 타입에서 부모타입의 기능을 호출할때 부모입자에서 보면 외부에서 호출한 것과 같다


### super - 부모참조
* 부모와 자식이 필드명이 같거나 메서드가 오버라이딩 되어 있으면, 자식에서 부모의 필드나 메서드를 호출할 수 없다
* 이때, super  키워드를 사용하면 부모를 참조할 수 있다.
* super  는 이름 그대로 부모 클래스의 대한 참조를 나타냄

### super - 생성자
* 상속 관계의 인스턴스를 생성하면 메모리 내부에는 자식과 부모 클래스가 각각 만들어 진다. 
* 따라서, 각각의 생성자도 모두 호출 되어야 한다
* 상속관계를 사용하면 자식 클래스의 생성자에서 부모 클래스의 생성자를 반드시 호출해야 한다(규칙)
* 호출할때는 `super()` 를 사용하면 된다
* 상속을 받으면 생성자의 첫줄에는 `super()`  를 사용하여 부모 클래스의 생성자를 호출 하여야 한다
* 예외로 `this()`  를 사용하기도 한다.  하지만 `super()`  는 자식의 생성자 안에서 언젠가는 반드시 호출되어야 한다
* 부모 클래스의 생성자가 기본생성자인 경우 `super()`  를 생략할 수 있다
* 생성자를 호출할 때 결과 적으로 최상위 부모 부터 실행되어 하나씩 아래로 내려오는 것이다.
* 초기화는 최상위 부모부터 이루어 진다. 왜냐하면  자식 생성자의 첫줄에서 부모 생성자를 호출해야 하기 때문
## 정리!!
* 상속 관계의 생성자 호출은 결과 적으로 부모에서 자식 순서로실행 
* 부모데이터를 먼저 초기화 하고 그다음 자식 데이터를 초기화 한다
* 상속 관계에서 자식 클래스의 생성자 첫줄에 반드시 super()  를 호출 해야함 단, 기본 생성자일때는 생략가능



