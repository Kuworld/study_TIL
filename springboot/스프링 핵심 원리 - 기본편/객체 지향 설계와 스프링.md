# 객체 지향 설계와 스프링

### Spring
-----------------------------------------
#### 스프링의 진짜 핵심
 * 자바언어 기반의 프레임워크
 * 자바의 가장 큰 특징 - `객체지향 언어`
 * 객체지향 언어가 가진 가장 강력한 특징을 살린 프레임 워크
 * 좋은 객체 지향 어플리케이션을 개발할 수 있게 도와 주는 도구
#### 좋은 객체 지향 프로그래밍
  * 객체 지향 프로그래밍은 프로그램을 유연하고 변경이 용이하게 만들어 대규모 소프트웨어에 사용
  * 조립하듯이
  * 갈아 끼우듯이
  * 컴포넌트를 쉽고 유연하게 변경하면서
#### 객체지향의 핵심 다형성
  * 역할과 구현으로 세상 구분
     - 역할과 구현으로 구분하면 세상이 단순해 지고, 유연해지며 변경도 편리해진다.
  * 운전자 역할 - 자동차 역할 ( K3, 아반떼, 테슬라 모델3)
  * 운전자가 k3를 타다가 테슬라 모델3 를 탄다고 해서 운전면허를 다시 따야 하는건 아니다
  * 운전자는(클라이 언트) 자동차(구현대상)의 내부 구조를 알 필요가 없다
  * 즉 클라이언트는 구현대상의 내부구조가 변경되어도 영향을 받지 않고,  구현대상 자체를 변경해도 영향을 받지 않는다
#### 자바언어의 다형성 활용
  * 역할 = 인터페이스
  * 구현 = 인터페이스를 구현한 클래스, 구현 객체
  * 역할과 구현을 명확하게 분리
#### 객체의 협력이라는 관계
  * 혼자있는 객체는 X
  * 클라이언트 = 요청, 서버 = 응답
#### 자바언어의 다형성
  * 오버라이딩 된 메서드가 실행된다
  * 다형성으로 인터페이스를 구현한 객체를 실행 시점에서 윤연하게 변경할 수 있다
  * 클래스 상속 관계도 다형성, 오버라이딩 적용 가능
#### 다형성의 본질
  - 인터페이스를 구현한 객체 인스터스를 실행시점에 유연하게 변경할 수 있다.
  - 본질을 이해하려면 협력이라는 객체사이의 관계에서 시작해야함
  - 크라이언트를 변경하지 않고, 서버의 구현기능을 유연하게 변경할 수 있다.
### 정리
 - 유연하고, 변경이 용이
 - 확장 가능한 설계
 - 클라이언트에 영향을 주지 않는 변경가능
 - `인터페이스를 안정적으로 잘 설계하는 것이 중요` **제일 중요**
 - 한계 : 인터페이스(역할) 자체가 변하면, 클라이언트, 서버 모두에 큰변경이 발생한다.
### 스프링과 객체지향
 - 다형성이 가장중요
 - 스프링은 다형성을 극대화
 - 제어의 역전(IoC), 의존 관계주입 (DI) 다형성을 활용해서 역할과 구현을 편리하게 다룰수 있게 지원

## SOLID
### SRP 단일 책임원칙 ( Single reposibility principle)
 - 한 클래스는 하나의 책임만 가진다.
 - 하나의 책임이라는 것은 모호
    1. 클 수 있고, 작을 수 있다.
    1. 문맥과 상황에 따라 다르다.
 - 중요한 기준은 변경이다. 변경이 있을 때 파급효과가 적으면 단일 책임 원칙을 잘 따른것
### OCP 개방 - 폐쇄 원칙 ( Open / closed principle)
 - 확장에는 열려있으나 변경에는 닫혀있어야 한다.
 - `다형성`을 활용하자!
 - 인터페이스를 구현한 새로운 클래스를 하나 만들어 새로운 기능을 구현
 >  > 문제점
>   >  ```java
>   >  MemberRepository m = new MemoryMemberRepository(); //기존 코드
>   >  MemberRepository m = new JdbcMemberRepository();// 변경 코드
>   > ```
>   >  - 구현 객체를 변경하려면 클라이언트 코드를 변경해야 한다.
>   >  - 분명 다형성을 사용하지만 OCP 원칙을 지킬 수 없다.
>   >  - 객체를 생성하고, 영관 관계를 맺어 주는 별도의 조립, 설정자가 필요하다.
### LSP 리스코프 치환 원칙 ( Liskov substitution principle)
 - 프로그램 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위타입 인터페이스로 바꿀 수 있어야 한다
 - 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원하기 위한 원칙, 인터페이스를 구현체를 믿고 사용하려면 이 원칙이 필요하다
 - 단순히 컴파일을 성공한다는것을 넘어서는 이야기
### ISP 인터페이스 분리 원칙 ( Insterface segregation principle)
 - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
 - 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리
 - 사용자 인터페이스 -> 운전자 클라이언트, 정비사 클라이언트로 분리
 - 인터페이스가 명확해 지고 대체 가능성이 ⏫
### DIP 의존관계 역전 원칙 ( Dependency inversion principle)
 - 프로그래머는 "추상화에 의존해야지, 구페화에 의존하면 안된다." 의존성 원칙은 이원칙을 따른다
 - 쉽게 이야기해서 구현 클래스에 의존하지 말고, 인터페이스에 의존하지 말라는 뜻
 - 앞서 얘기한 역할에 의존하게 해야 한다는 것과 같다. 구현체에 의존하게 되면 변경이 아주 어려워 진다.
  ```java
      MemberRepository m = new MemoryMemberRepository();
  ```
 - MemberService 는 인터페이스에도 의존하지만 구현 클래스도 동시에 의존한다.(클라이언트가 구현클래스를 직접 선택)
 - DIP 위반!!!!!!!!!!
## 정리
       * 객체지향의 핵심은 다형성
       * 다형성만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다
       * 다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.
       * 다형성 만으로는 OCP, DIP 를 지킬수 없다.
       * 뭔가 더 필요하다....
### 다시 스프링으로...
- 스프링은 DI(의존관계, 의존성 주입), DI 컨테이너 제공으로 다형성 + OCP, DIP 를 가능하게 한다.
- 클라이언트 코드 변경없이 기능 확장
- 부품을 교체하듯이 개발이 가능하다.
## 정리
1. 모든 설계에 역할과 구현을 분리하자
1. 자동차, 공연의 예를 떠올리자
1. 공연을 설계하듯이 배역을 만들어 두고, 배우는 언제든지 `유연`하게 `변경`할 수 있도록 만드는 것이 좋은 객체지향 설계이다.
   ### 실무에서의 고민
     * 인터페이스르 도입하면 추상화라는 비용이 발생
     * 기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용하고, 향후 꼭 필요한 때 리팩터링해서 인터페이스를 도입하는 것도 방법이다.
   



